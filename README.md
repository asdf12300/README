## top
top 명령어는 시스템의 **현재 상태를 실시간으로** 보여주는 도구이다.

- *CPU 사용량, 메모리 사용량, 스왑 메모리 상태, 각 프로세스의 상태를 한눈에 확인할 수 있다.*  

- top을 실행하면 실행 중인 프로세스 목록이 지속적으로 갱신되며, 사용자는 특정 프로세스를 정렬하거나 종료하는 등의 상호작용을 할 수 있다.  

  >이를 통해 시스템의 부하를 파악하고, 필요한 조치를 취할 수 있다.

**사용예시**

<img width="1093" height="188" alt="image" src="https://github.com/user-attachments/assets/243e1e24-7f10-474c-97b7-fd0617b994cf" />

| 줄 번호 | 설명 |
|:-------:|:----|
| 1       | 시스템 시간, 부팅 후 시간(up time), 로그인 사용자 수, 부하(load average) |
| 2       | 전체 프로세스 수, 실행중, 대기중, 정지, 좀비 프로세스 수 |
| 3       | CPU 사용률: 사용자(us), 시스템(sy), nice(ni), 유휴(id), I/O 대기(wa), 하드웨어 인터럽트(hi), 소프트웨어 인터럽트(si), 스틸(st) |
| 4       | 메모리 상태: 총 메모리, 여유, 사용 중, 버퍼/캐시 |
| 5       | 스왑 메모리 상태: 총, 여유, 사용 중, 사용 가능한 메모리 |
| 6       | 프로세스 테이블 헤더: PID, 사용자, 우선순위(PR), nice값(NI), 가상메모리(VIRT), 실제메모리(RES), 공유메모리(SHR), 상태(S), CPU%, MEM%, 누적 CPU시간(TIME+), 명령어(CMD) |
| 7~n     | 각 프로세스 정보 한 줄씩. PID, 사용자, 상태, 메모리, CPU 사용률 등 표시 |

[이미지출처](https://develop-historychosun.tistory.com/85)

---
## ps
ps 명령어는 **현재 실행 중인 프로세스를 스냅샷 형태로 확인**하는 도구이다.

- `ps aux`와 같은 옵션을 사용하면 모든 사용자의 프로세스를 확인할 수 있으며, 각 프로세스의 *PID, CPU 및 메모리 사용량, 실행 상태 등의 상세 정보를 확인할 수 있다.*

- `ps -ef` 옵션은 부모 프로세스(PPID)를 포함하여 전체 프로세스를 나열한다.

  > 시스템 상태를 한 시점에서 분석하거나 스크립트에서 자동화된 모니터링을 구현할 때 자주 사용된다.


**사용 예시**
<img width="1103" height="82" alt="image" src="https://github.com/user-attachments/assets/24813d61-4049-44ab-befe-d214c66c39ea" />

| 컬럼 | 의미 | 설명 |
|:----:|:----:|:----|
| PID  | Process ID | 프로세스의 고유 식별 번호. 각 프로세스마다 하나씩 있음 |
| TTY  | Terminal | 프로세스를 실행한 터미널(콘솔) 이름. 백그라운드 프로세스는 `?`로 표시 |
| TIME | CPU Time | 해당 프로세스가 사용한 **누적 CPU 시간**. 초 단위가 아니라 `분:초` 형식 |
| CMD  | Command | 실행된 **명령어 이름** 또는 경로. 어떤 프로그램/명령이 실행되었는지 표시 |

[이미지출처](https://develop-historychosun.tistory.com/85)

---
## jobs
jobs 명령어는 쉘에서 **백그라운드로 실행 중인 작업을 확인**할 수 있도록 도와준다.

- 사용자가 명령어 뒤에 &를 붙여 백그라운드에서 작업을 실행하면, jobs를 통해 현재 *활성화된 모든 백그라운드 작업의 목록과 상태를 확인할 수 있다.*

- 특정 작업을 포그라운드로 전환할 때는 `fg %번호`와 같이 사용하여 다시 제어할 수 있으므로, 여러 작업을 동시에 실행하면서 필요한 작업을 선택적으로 관리할 수 있다.


**사용 예시**
##### 백그라운드에서 ping 실행
```
user@linux:~$ ping google.com &
[1] 100
```

##### 현재 백그라운드 작업 확인
```user@linux:~$ jobs
[1]+  Running                 ping google.com &
```

##### sleep 명령어 실행 후 Ctrl+Z로 중단
```
user@linux:~$ sleep 1000
^Z
[2]+  Stopped                 sleep 1000
```

##### 다시 jobs로 확인
```
user@linux:~$ jobs
[1]-  Running                 ping google.com &
[2]+  Stopped                 sleep 1000
```

---
## kill
kill 명령어는 **프로세스를 종료할 때** 사용된다.

- 일반적으로 `kill PID` 형태로 사용하며, 특정 PID를 가진 프로세스를 정상적으로 종료할 수 있다.

  - 필요할 경우 `kill -9 PID`와 같이 ***강제 종료 옵션을 사용하여 프로세스를 즉시 종료할 수도 있다.***

>이 명령어는 문제가 있는 프로세스를 종료하거나 시스템 리소스를 확보할 때 필수적으로 사용되며, 다른 명령어들과 함께 사용하여 효율적인 프로세스 관리를 가능하게 한다.


**사용예시**
##### 백그라운드에서 sleep 실행
```
user@linux:~$ sleep 1000 &
[1] 1234
```

##### 현재 백그라운드 작업 확인
```
user@linux:~$ jobs
[1]+  Running                 sleep 1000 &
```

##### kill로 프로세스 종료
```
user@linux:~$ kill 1234
```

##### 종료 후 jobs로 확인
```
user@linux:~$ jobs
[1]+  Terminated              sleep 1000
```

---
## 정리

| 명령어 | 출력 내용 | 기능 |
|:------:|:---------:|:----:|
| `top`  | CPU, 메모리, 스왑, 프로세스 상태 | 실시간 갱신, 프로세스 정렬 및 종료 |
| `ps`   | PID, PPID, CPU/메모리 사용량, 상태 | 특정 시점 상태 확인, 스크립트 자동화 |
| `jobs` | 현재 쉘에서 실행 중인 작업 목록 | 백그라운드 작업 확인 및 포그라운드 전환 |
| `kill` | 없음 (성공/실패 메시지) | 특정 프로세스 종료, 강제 종료 옵션 지원 |

